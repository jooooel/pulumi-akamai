// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.akamai.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class DatastreamElasticsearchConnector {
    /**
     * @return **Secret**. The certification authority (CA) certificate used to verify the origin server&#39;s certificate. It&#39;s needed if the certificate stored in `client_cert` is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     * 
     */
    private @Nullable String caCert;
    /**
     * @return **Secret**. The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     * 
     */
    private @Nullable String clientCert;
    /**
     * @return **Secret**. The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     * 
     */
    private @Nullable String clientKey;
    /**
     * @return The name of the connector.
     * 
     */
    private String connectorName;
    /**
     * @return Content type to pass in the log file header.
     * 
     */
    private @Nullable String contentType;
    /**
     * @return A human-readable name for the request&#39;s custom header, containing only alphanumeric, dash, and underscore characters.
     * 
     */
    private @Nullable String customHeaderName;
    /**
     * @return The custom header&#39;s contents passed with the request that contains information about the client connection.
     * 
     */
    private @Nullable String customHeaderValue;
    /**
     * @return The Elasticsearch bulk endpoint URL in the format: `https://&lt;hostname&gt;.elastic-cloud.com:9243/_bulk/`. Set `index_name` in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs.
     * &lt;br&gt;Learn more about how to [Stream logs to Elasticsearch](https://techdocs.akamai.com/datastream2/docs/stream-elasticsearch).
     * 
     */
    private String endpoint;
    /**
     * @return **Secret**. The index name of the Elastic cloud where you want to store log files.
     * 
     */
    private String indexName;
    private @Nullable Boolean mTls;
    /**
     * @return **Secret**. The Elasticsearch basic access authentication password.
     * 
     */
    private String password;
    /**
     * @return The hostname that verifies the server&#39;s certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     * 
     */
    private @Nullable String tlsHostname;
    /**
     * @return **Secret**. The Elasticsearch basic access authentication username.
     * 
     */
    private String userName;

    private DatastreamElasticsearchConnector() {}
    /**
     * @return **Secret**. The certification authority (CA) certificate used to verify the origin server&#39;s certificate. It&#39;s needed if the certificate stored in `client_cert` is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     * 
     */
    public Optional<String> caCert() {
        return Optional.ofNullable(this.caCert);
    }
    /**
     * @return **Secret**. The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     * 
     */
    public Optional<String> clientCert() {
        return Optional.ofNullable(this.clientCert);
    }
    /**
     * @return **Secret**. The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     * 
     */
    public Optional<String> clientKey() {
        return Optional.ofNullable(this.clientKey);
    }
    /**
     * @return The name of the connector.
     * 
     */
    public String connectorName() {
        return this.connectorName;
    }
    /**
     * @return Content type to pass in the log file header.
     * 
     */
    public Optional<String> contentType() {
        return Optional.ofNullable(this.contentType);
    }
    /**
     * @return A human-readable name for the request&#39;s custom header, containing only alphanumeric, dash, and underscore characters.
     * 
     */
    public Optional<String> customHeaderName() {
        return Optional.ofNullable(this.customHeaderName);
    }
    /**
     * @return The custom header&#39;s contents passed with the request that contains information about the client connection.
     * 
     */
    public Optional<String> customHeaderValue() {
        return Optional.ofNullable(this.customHeaderValue);
    }
    /**
     * @return The Elasticsearch bulk endpoint URL in the format: `https://&lt;hostname&gt;.elastic-cloud.com:9243/_bulk/`. Set `index_name` in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs.
     * &lt;br&gt;Learn more about how to [Stream logs to Elasticsearch](https://techdocs.akamai.com/datastream2/docs/stream-elasticsearch).
     * 
     */
    public String endpoint() {
        return this.endpoint;
    }
    /**
     * @return **Secret**. The index name of the Elastic cloud where you want to store log files.
     * 
     */
    public String indexName() {
        return this.indexName;
    }
    public Optional<Boolean> mTls() {
        return Optional.ofNullable(this.mTls);
    }
    /**
     * @return **Secret**. The Elasticsearch basic access authentication password.
     * 
     */
    public String password() {
        return this.password;
    }
    /**
     * @return The hostname that verifies the server&#39;s certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     * 
     */
    public Optional<String> tlsHostname() {
        return Optional.ofNullable(this.tlsHostname);
    }
    /**
     * @return **Secret**. The Elasticsearch basic access authentication username.
     * 
     */
    public String userName() {
        return this.userName;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(DatastreamElasticsearchConnector defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String caCert;
        private @Nullable String clientCert;
        private @Nullable String clientKey;
        private String connectorName;
        private @Nullable String contentType;
        private @Nullable String customHeaderName;
        private @Nullable String customHeaderValue;
        private String endpoint;
        private String indexName;
        private @Nullable Boolean mTls;
        private String password;
        private @Nullable String tlsHostname;
        private String userName;
        public Builder() {}
        public Builder(DatastreamElasticsearchConnector defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.caCert = defaults.caCert;
    	      this.clientCert = defaults.clientCert;
    	      this.clientKey = defaults.clientKey;
    	      this.connectorName = defaults.connectorName;
    	      this.contentType = defaults.contentType;
    	      this.customHeaderName = defaults.customHeaderName;
    	      this.customHeaderValue = defaults.customHeaderValue;
    	      this.endpoint = defaults.endpoint;
    	      this.indexName = defaults.indexName;
    	      this.mTls = defaults.mTls;
    	      this.password = defaults.password;
    	      this.tlsHostname = defaults.tlsHostname;
    	      this.userName = defaults.userName;
        }

        @CustomType.Setter
        public Builder caCert(@Nullable String caCert) {
            this.caCert = caCert;
            return this;
        }
        @CustomType.Setter
        public Builder clientCert(@Nullable String clientCert) {
            this.clientCert = clientCert;
            return this;
        }
        @CustomType.Setter
        public Builder clientKey(@Nullable String clientKey) {
            this.clientKey = clientKey;
            return this;
        }
        @CustomType.Setter
        public Builder connectorName(String connectorName) {
            this.connectorName = Objects.requireNonNull(connectorName);
            return this;
        }
        @CustomType.Setter
        public Builder contentType(@Nullable String contentType) {
            this.contentType = contentType;
            return this;
        }
        @CustomType.Setter
        public Builder customHeaderName(@Nullable String customHeaderName) {
            this.customHeaderName = customHeaderName;
            return this;
        }
        @CustomType.Setter
        public Builder customHeaderValue(@Nullable String customHeaderValue) {
            this.customHeaderValue = customHeaderValue;
            return this;
        }
        @CustomType.Setter
        public Builder endpoint(String endpoint) {
            this.endpoint = Objects.requireNonNull(endpoint);
            return this;
        }
        @CustomType.Setter
        public Builder indexName(String indexName) {
            this.indexName = Objects.requireNonNull(indexName);
            return this;
        }
        @CustomType.Setter
        public Builder mTls(@Nullable Boolean mTls) {
            this.mTls = mTls;
            return this;
        }
        @CustomType.Setter
        public Builder password(String password) {
            this.password = Objects.requireNonNull(password);
            return this;
        }
        @CustomType.Setter
        public Builder tlsHostname(@Nullable String tlsHostname) {
            this.tlsHostname = tlsHostname;
            return this;
        }
        @CustomType.Setter
        public Builder userName(String userName) {
            this.userName = Objects.requireNonNull(userName);
            return this;
        }
        public DatastreamElasticsearchConnector build() {
            final var o = new DatastreamElasticsearchConnector();
            o.caCert = caCert;
            o.clientCert = clientCert;
            o.clientKey = clientKey;
            o.connectorName = connectorName;
            o.contentType = contentType;
            o.customHeaderName = customHeaderName;
            o.customHeaderValue = customHeaderValue;
            o.endpoint = endpoint;
            o.indexName = indexName;
            o.mTls = mTls;
            o.password = password;
            o.tlsHostname = tlsHostname;
            o.userName = userName;
            return o;
        }
    }
}
