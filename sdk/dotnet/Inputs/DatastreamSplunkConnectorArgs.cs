// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Akamai.Inputs
{

    public sealed class DatastreamSplunkConnectorArgs : global::Pulumi.ResourceArgs
    {
        [Input("caCert")]
        private Input<string>? _caCert;

        /// <summary>
        /// **Secret**. The certification authority (CA) certificate used to verify the origin server's certificate. It's needed if the certificate stored in `client_cert` is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        /// </summary>
        public Input<string>? CaCert
        {
            get => _caCert;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _caCert = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("clientCert")]
        private Input<string>? _clientCert;

        /// <summary>
        /// **Secret**. The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        /// </summary>
        public Input<string>? ClientCert
        {
            get => _clientCert;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _clientCert = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("clientKey")]
        private Input<string>? _clientKey;

        /// <summary>
        /// **Secret**. The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        /// </summary>
        public Input<string>? ClientKey
        {
            get => _clientKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _clientKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        /// </summary>
        [Input("compressLogs")]
        public Input<bool>? CompressLogs { get; set; }

        [Input("connectorId")]
        public Input<int>? ConnectorId { get; set; }

        /// <summary>
        /// The name of the connector.
        /// </summary>
        [Input("connectorName", required: true)]
        public Input<string> ConnectorName { get; set; } = null!;

        /// <summary>
        /// A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters.
        /// </summary>
        [Input("customHeaderName")]
        public Input<string>? CustomHeaderName { get; set; }

        /// <summary>
        /// The custom header's contents passed with the request that contains information about the client connection.
        /// </summary>
        [Input("customHeaderValue")]
        public Input<string>? CustomHeaderValue { get; set; }

        [Input("eventCollectorToken", required: true)]
        private Input<string>? _eventCollectorToken;

        /// <summary>
        /// **Secret**. The Event Collector token associated with your Splunk account. See [View usage of Event Collector token in Splunk](https://docs.splunk.com/Documentation/Splunk/8.0.3/Data/UsetheHTTPEventCollector).
        /// </summary>
        public Input<string>? EventCollectorToken
        {
            get => _eventCollectorToken;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _eventCollectorToken = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("mTls")]
        public Input<bool>? MTls { get; set; }

        /// <summary>
        /// The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        /// </summary>
        [Input("tlsHostname")]
        public Input<string>? TlsHostname { get; set; }

        /// <summary>
        /// Enter the secure URL where you want to send and store your logs.
        /// </summary>
        [Input("url", required: true)]
        public Input<string> Url { get; set; } = null!;

        public DatastreamSplunkConnectorArgs()
        {
        }
        public static new DatastreamSplunkConnectorArgs Empty => new DatastreamSplunkConnectorArgs();
    }
}
